# -*- coding: utf-8 -*-
"""FeedForwardNeuralNetwork

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FvnOTObjl-0QwQKexdbIBvfm6yzh5F1Z

# Imports
we will be using the following packages
  - **Pytorch** a neural network library supported by Meta
  - **Numpy** a package used to manipulate data in python
  - **MNIST** the dataset package we will be using
  - **matplotlib** this package is used to show images and plots
"""

import torch
from torch import nn, optim
from torch.nn import functional as f
from torch.utils.data import DataLoader
import numpy as np
from torchvision.datasets import MNIST
from torchvision import transforms

import matplotlib.pyplot as plt

"""# Creating Training and Testing Data

"""

# Download Dataset
train = MNIST('data', train = True, transform = transforms.ToTensor(), download = True)
test  = MNIST('data', train = False, transform = transforms.ToTensor(), download = True)

# Split x and y from the data
train_X, train_y = zip(*list(train))
test_X, test_y = zip(*list(test))

# Convert Data to cuda tensor from numpy
train_X = torch.from_numpy(np.stack(train_X)).to('cuda')
train_y = torch.from_numpy(np.stack(train_y)).to('cuda')
test_X = torch.from_numpy(np.stack(test_X)).to('cuda')
test_y = torch.from_numpy(np.stack(test_y)).to('cuda')

"""# Data Loader
Load the data downloaded using MNIST into Torch DataLoader


"""

BATCH_SIZE = 128

train_loader = torch.utils.data.DataLoader(
    dataset = list(zip(train_X, train_y) ),
    batch_size = BATCH_SIZE,
    shuffle = True
)

test_loader = torch.utils.data.DataLoader(
    dataset = list(zip(test_X, test_y) ),
    batch_size = BATCH_SIZE,
    shuffle = True
)

"""# Build the Feed Forward Neural Network"""

class Net(nn.Module):
    def __init__(self): #initializes a class
        super().__init__() #initializes the superclass
        self.conv = nn.Sequential(

            nn.Conv2d(in_channels = 1, out_channels = 5, kernel_size = 5, padding = 1), #28*28*1 -> 26*26*5
            nn.ReLU(),
            #same thing as above
            nn.Conv2d(in_channels = 5, out_channels = 5, kernel_size = 5, padding = 2), #26*26*5 -> 26*26*5
            nn.ReLU()
        )

        self.dense = nn.Sequential(
            nn.Linear(in_features = 26*26*5, out_features = 26*20),
            nn.ReLU(),
            nn.Linear(in_features = 26*20, out_features = 26*10),
            nn.ReLU(),
            nn.Linear(in_features = 26*10, out_features = 10),
            nn.Softmax(dim = 1)
        )
    def forward(self, X):
        X = self.conv(X)
        X = X.view(-1, 26*26*5)
        X = self.dense(X)
        return X

"""# Train Function"""

def train(net, learning_rate, n_epochs, train_loader, test_loader):
    optimizer = optim.Adam(params = net.parameters(), lr = learning_rate)
    #loss functions help us optimize the neural net.
    loss_function = nn.CrossEntropyLoss()
    #for each cycle
    for epoch in range(n_epochs):
      #for each picture
        for X, y in train_loader:
          #this essentially helps by making the process faster
            optimizer.zero_grad()
          #grabs a prediction
            predictions = net(X)
          #finds the loss found and tries to optimize the A.I.
            loss = loss_function(predictions, y)
            loss.backward()
            optimizer.step()
        #shows loss per cycle
        with torch.no_grad():
            loss = 0
            for batchnum, (X, y) in enumerate(test_loader):
                predictions = net(X)
                loss += loss_function(predictions, y)
            loss /= batchnum
        print('Epoch %i has test loss %.8f'%(epoch, loss) )

"""## Create and Train the network"""

net = Net().to('cuda')

train(net,
      .0001,
      10,
      train_loader,
      test_loader)

help(train)



"""# Helper Functions


"""

test_images = list(test_loader)[0]
def show(img):
  plt.figure()
  plt.imshow(img, cmap = 'gray')

def get_image():
  return test_images[0][np.random.randint(low=0, high = BATCH_SIZE)]

def make(img):
  return img.to("cpu").detach().numpy().reshape(28,28)

def say(pred):
  return np.argmax(pred.to("cpu").detach(), axis = 1).item()

"""# Testing the AI"""

for i in range(5):
  img = get_image()
  show(make(img))
  with torch.no_grad():
    pred = net(img.reshape(-1,1,28,28))
  print(say(pred))

with torch.no_grad():
  pred = net(img.reshape(-1,1,28,28))
say(pred)